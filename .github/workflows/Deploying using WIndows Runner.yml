name: Deploying AI Doctor to RDP (VPS Own Server/Machine)

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allows manual triggering

jobs:
  build-and-deploy:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4  # Updated to the latest version

      - name: Setup .NET
        uses: actions/setup-dotnet@v4  # Updated to the latest version
        with:
          dotnet-version: '9.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4  # Updated to the latest version
        with:
          node-version: '20'

      - name: Build Backend
        run: |
          cd AIDoctor.Server
          dotnet publish -c Release -o ../publish

      - name: Build Frontend
        run: |
          cd AIDoctor.Client
          npm install
          npm audit fix
          npm run build
          xcopy dist ..\publish\wwwroot /E /H /C /I /Y

      - name: Deploy to RDP
        timeout-minutes: 10
        shell: powershell
        env:
          RDP_HOST: "139.185.55.205"
          RDP_PORT: "5986"
          RDP_USER: "Aaban"
          RDP_PASS: "${{ secrets.RDP_PASSWORD }}"
        run: |
          Write-Output "Starting deployment to RDP machine at $env:RDP_HOST..."

          # Set up credentials for WinRM
          $SecurePass = ConvertTo-SecureString $env:RDP_PASS -AsPlainText -Force
          $Credential = New-Object System.Management.Automation.PSCredential($env:RDP_USER, $SecurePass)

          # Add the RDP host to TrustedHosts on the runner
          Write-Output "Configuring TrustedHosts..."
          $CurrentTrustedHosts = (Get-Item WSMan:\localhost\Client\TrustedHosts).Value
          if ($CurrentTrustedHosts -notlike "*$env:RDP_HOST*") {
            if ($CurrentTrustedHosts) {
              Set-Item WSMan:\localhost\Client\TrustedHosts -Value "$CurrentTrustedHosts,$env:RDP_HOST" -Force
            } else {
              Set-Item WSMan:\localhost\Client\TrustedHosts -Value $env:RDP_HOST -Force
            }
          }

          # Allow unencrypted traffic on the client (GitHub Actions runner)
          Write-Output "Allowing unencrypted WinRM traffic..."
          Set-Item -Path WSMan:\localhost\Client\AllowUnencrypted -Value $true -Force

          # Zip the publish folder to reduce transfer size
          Write-Output "Zipping the publish folder..."
          Compress-Archive -Path "publish/*" -DestinationPath "publish.zip" -Force

          # Create a new PowerShell session to the RDP machine with retries
          Write-Output "Establishing WinRM session..."
          $retries = 3
          $retryCount = 0
          $sessionSuccess = $false
          while ($retryCount -lt $retries -and -not $sessionSuccess) {
            try {
              $Session = New-PSSession -ComputerName $env:RDP_HOST -Port $env:RDP_PORT -Credential $Credential -Authentication Basic -SessionOption (New-PSSessionOption -OperationTimeout 60000) -ErrorAction Stop
              Write-Output "WinRM session established successfully."
              $sessionSuccess = $true
            } catch {
              Write-Output "Attempt $($retryCount + 1): Failed to establish WinRM session - $($_.Exception.Message)"
              Start-Sleep -Seconds 10
              $retryCount++
              if ($retryCount -eq $retries) {
                Write-Error "Failed to establish WinRM session after $retries attempts."
                exit 1
              }
            }
          }

          # Stop the running application and ensure files are released
          Write-Output "Stopping the running app..."
          Invoke-Command -Session $Session -ScriptBlock {
            $processes = Get-Process -Name "dotnet" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*AIDoctor*" }
            if ($processes) {
              foreach ($process in $processes) {
                Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
                Write-Output "Stopped process ID $($process.Id)"
              }
            } else {
              Write-Output "No running AIDoctor app found."
            }
            # Wait for file handles to be released
            Start-Sleep -Seconds 5
          }

          # Attempt to delete the publish folder with retries
          Write-Output "Deleting existing publish folder..."
          Invoke-Command -Session $Session -ScriptBlock {
            $retries = 3
            $retryCount = 0
            $success = $false
            while ($retryCount -lt $retries -and -not $success) {
              try {
                Remove-Item -Path "C:\AI-Doctor\publish" -Recurse -Force -ErrorAction Stop
                Write-Output "Publish folder deleted successfully."
                $success = $true
              } catch {
                Write-Output "Attempt $($retryCount + 1): Failed to delete publish folder - $($_.Exception.Message)"
                Start-Sleep -Seconds 5
                # Try to identify and stop any process using the folder
                $lockedFiles = Get-ChildItem -Path "C:\AI-Doctor\publish" -Recurse -ErrorAction SilentlyContinue
                if ($lockedFiles) {
                  taskkill /IM dotnet.exe /F /T 2>$null
                }
                $retryCount++
                if ($retryCount -eq $retries -and -not $success) {
                  Write-Error "Failed to delete publish folder after $retries attempts."
                  exit 1
                }
              }
            }
          }

          # Copy the zip file to RDP
          Write-Output "Copying the zip file to RDP..."
          Copy-Item -Path "publish.zip" -Destination "C:\AI-Doctor\publish.zip" -ToSession $Session -Force

          # Unzip the files on the RDP machine
          Write-Output "Unzipping files on RDP..."
          Invoke-Command -Session $Session -ScriptBlock {
            Expand-Archive -Path "C:\AI-Doctor\publish.zip" -DestinationPath "C:\AI-Doctor\publish" -Force
            Remove-Item -Path "C:\AI-Doctor\publish.zip" -Force
          }

          # Start the app on port 5001 (to match FRP tunnel)
          Write-Output "Starting the app on port 5001..."
          Invoke-Command -Session $Session -ScriptBlock {
            Start-Process -FilePath "dotnet" -ArgumentList "C:\AI-Doctor\publish\AIDoctor.Server.dll --urls http://0.0.0.0:5001" -WorkingDirectory "C:\AI-Doctor\publish" -NoNewWindow
            Start-Sleep -Seconds 5  # Give the app a moment to start
          }

          # Verify the app is running on localhost:5001
          Write-Output "Verifying app is running on localhost:5001..."
          Invoke-Command -Session $Session -ScriptBlock {
            $appUrl = "http://localhost:5001"
            $maxAttempts = 10
            $attempt = 1
            while ($attempt -le $maxAttempts) {
              try {
                $response = Invoke-WebRequest -Uri $appUrl -TimeoutSec 5 -ErrorAction Stop
                Write-Output "App is running on $appUrl with status code $($response.StatusCode)"
                break
              } catch {
                Write-Output "Attempt $attempt of $maxAttempts: Failed to connect to $appUrl - $($_.Exception.Message)"
                if ($attempt -eq $maxAttempts) {
                  Write-Error "App failed to start on $appUrl after $maxAttempts attempts"
                  exit 1
                }
                Start-Sleep -Seconds 5
                $attempt++
              }
            }
          }

          # Check network connectivity to VPS
          Write-Output "Checking network connectivity to VPS..."
          Invoke-Command -Session $Session -ScriptBlock {
            $result = Test-NetConnection -ComputerName "139.185.55.205" -Port 7000
            if (-not $result.TcpTestSucceeded) {
              Write-Output "Cannot reach VPS on port 7000. Attempting to restart network services..."
              net stop dnscache
              net start dnscache
              ipconfig /flushdns
              Start-Sleep -Seconds 5
              $result = Test-NetConnection -ComputerName "139.185.55.205" -Port 7000
              if (-not $result.TcpTestSucceeded) {
                Write-Error "Still cannot reach VPS on port 7000. FRP tunnel may be broken."
                exit 1
              }
            }
            Write-Output "Network connectivity to VPS is good."
          }

          # Restart frpc to ensure the tunnel is active
          Write-Output "Restarting frpc to ensure tunnel is active..."
          Invoke-Command -Session $Session -ScriptBlock {
            taskkill /IM frpc.exe /F 2>$null
            Start-Sleep -Seconds 2
            Start-Process -FilePath "C:\AI-Doctor-App\start-frpc.bat" -NoNewWindow
            Write-Output "frpc restarted."
            Start-Sleep -Seconds 5  # Give frpc time to reconnect to frps
          }

          # Close the WinRM session
          Write-Output "Closing WinRM session..."
          Remove-PSSession $Session

          Write-Output "Deployment completed."

      - name: Verify Deployment
        shell: powershell
        run: |
          $url = "http://139.185.55.205:8080"
          Write-Output "Waiting for the app to start at $url..."

          $maxAttempts = 10
          $attempt = 1
          $delaySeconds = 10

          while ($attempt -le $maxAttempts) {
            try {
              Write-Output "Attempt $attempt of $maxAttempts: Checking $url..."
              $response = Invoke-WebRequest -Uri $url -TimeoutSec 5 -ErrorAction Stop -UseBasicParsing
              Write-Output "Success: App is responding at $url with status code $($response.StatusCode)"
              exit 0
            } catch {
              Write-Output "Attempt $attempt of $maxAttempts: Failed to connect to $url - $($_.Exception.Message)"
              if ($attempt -eq $maxAttempts) {
                Write-Error "Deployment failed: App not responding at $url after $maxAttempts attempts"
                exit 1
              }
              Start-Sleep -Seconds $delaySeconds
              $attempt++
            }
          }
